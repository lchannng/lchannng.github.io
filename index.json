[{"categories":null,"content":"1 序 前一段时间疫情爆发，周末宅家里闲来无事，写点小玩具，期间使用并稍微深入学习了一下 MongoDB 。 本文主要记录一下在学习、使用 MongoDB 过程中遇到的一些问题和学到的一些姿势。 ","date":"2021-07-15","objectID":"/2021-07-14-by-talk-of-mongodb/:1:0","tags":["MongoDB"],"title":"MongoDB杂谈","uri":"/2021-07-14-by-talk-of-mongodb/"},{"categories":null,"content":"2 Objectid ","date":"2021-07-15","objectID":"/2021-07-14-by-talk-of-mongodb/:2:0","tags":["MongoDB"],"title":"MongoDB杂谈","uri":"/2021-07-14-by-talk-of-mongodb/"},{"categories":null,"content":"2.1 数据结构 在 MongoDB 中，集合中每个文档都需要一个 唯一的 _id 字段作为主键，如果插入的文档没有 _id 字段， MongoDB 会自动生成一个 ObjectId 作为 _id。 ObjectId是一个12字节 BSON 类型数据，最初的数据格式如下： a 4-byte value representing the seconds since the Unix epoch (which will not run out of seconds until the year 2106) a 3-byte machine identifier (usually derived from the MAC address), a 2-byte process id, and a 3-byte counter, starting with a random value. timestamp(big endian) machine hash pid counter |\u003c-----------------\u003e|\u003c------------\u003e|\u003c-------\u003e|\u003c------------\u003e| [----|----|----|----|----|----|----|----|----|----|----|----] 0 4 8 12 在 MongoDB 最新版本中，ObjectId 的格式有所变化： a 4-byte timestamp value, representing the ObjectId’s creation, measured in seconds since the Unix epoch a 5-byte random value a 3-byte incrementing counter, initialized to a random value timestamp(big endian) process unique data counter |\u003c-----------------\u003e|\u003c----------------------\u003e|\u003c------------\u003e| [----|----|----|----|----|----|----|----|----|----|----|----] 0 4 8 12 如上所示，主要变化在中间5个字节的，由原来的 3字节机器名称hash + 2字节进程id改为 5字节随机值，官方driver里面的描述是 system/process unique data。 这个改动的原因可以在 MongoDB 的特性设计文档中找到: Random Value: Originally, this field consisted of the Machine ID and Process ID fields. There were numerous divergences between drivers due to implementation choices, and the Machine ID field traditionally used the MD5 hashing algorithm which can’t be used on FIPS compliant machines. In order to allow for a similar behaviour among all drivers and the MongoDB Server, these two fields have been collated together into a single 5-byte random value, unique to a machine and process. 大概的原因是因为 MD5 算法不允许在需要遵循 FIPS 140-2 (美国政府安全标准)的机器上使用，为了统一各种语言的 driver 和平台下的实现和表现，采用了5字节系统唯一的随机数值作为一个机器的标识码。 除此之外，原来 3 byte + 2 byte的形式在有些使用场景中容易获得同样的数值，举个栗子。 在容器中部署 Mongo 的实例，系统编排启动、重启的一批容器，自动启动Mongo的时候，由于容器使用同样的镜像，执行同样的步骤，很大概率会出现相同pid的情况，而且机器名称也很可能是一样的。 ","date":"2021-07-15","objectID":"/2021-07-14-by-talk-of-mongodb/:2:1","tags":["MongoDB"],"title":"MongoDB杂谈","uri":"/2021-07-14-by-talk-of-mongodb/"},{"categories":null,"content":"2.2 driver实现 MongoDB driver在首次启动/首次生成 ObjectID 的时候，会初始化一次机器识别码和随机一个couter初始值，但是不同driver中间的实现五花八门。 /*C版本 https://github.com/mongodb/mongo-c-driver/blob/454a01422ee61d2add82f054aa3799750b7947e2/src/libbson/src/bson/bson-context.c#L268 * C版本将时间、进程id、主机名称异或得到一个随机种子，再随机5字节机器码和counter初始值。 */ static void _bson_context_init_random (bson_context_t *context, bool init_sequence) { int64_t rand_bytes; struct timeval tv; unsigned int seed = 0; char hostname[HOST_NAME_MAX]; char *ptr; int hostname_chars_left; /* * The seed consists of the following xor'd together: * - current time in seconds * - current time in milliseconds * - current pid * - current hostname */ bson_gettimeofday (\u0026tv); seed ^= (unsigned int) tv.tv_sec; seed ^= (unsigned int) tv.tv_usec; seed ^= (unsigned int) context-\u003epid; context-\u003egethostname (hostname); hostname_chars_left = strlen (hostname); ptr = hostname; while (hostname_chars_left) { uint32_t hostname_chunk = 0; uint32_t to_copy = hostname_chars_left \u003e 4 ? 4 : hostname_chars_left; memcpy (\u0026hostname_chunk, ptr, to_copy); seed ^= (unsigned int) hostname_chunk; hostname_chars_left -= to_copy; ptr += to_copy; } #ifndef BSON_HAVE_RAND_R srand (seed); #endif /* Generate a seed for the random starting position of our increment * bytes and the five byte random number. */ if (init_sequence) { /* We mask off the last nibble so that the last digit of the OID will * start at zero. Just to be nice. */ context-\u003eseq32 = _get_rand (\u0026seed) \u0026 0x007FFFF0; } rand_bytes = _get_rand (\u0026seed); rand_bytes \u003c\u003c= 32; rand_bytes |= _get_rand (\u0026seed); /* Copy five random bytes, endianness does not matter. */ memcpy (\u0026context-\u003erand, (char *) \u0026rand_bytes, sizeof (context-\u003erand)); } /* golang版本 https://github.com/mongodb/mongo-go-driver/blob/master/bson/primitive/objectid.go * go版本使用 rand.Reader 直接产生随机数，rand.Reader 是一个密码学安全的随机数生成器的公共实例 * rand.Reader在Linux下使用/dev/urandom实现，在windows下使用 RtlGenRandom 实现 */ ... var objectIDCounter = readRandomUint32() var processUnique = processUniqueBytes() ... func processUniqueBytes() [5]byte { var b [5]byte _, err := io.ReadFull(rand.Reader, b[:]) if err != nil { panic(fmt.Errorf(\"cannot initialize objectid package with crypto.rand.Reader: %v\", err)) } return b } func readRandomUint32() uint32 { var b [4]byte _, err := io.ReadFull(rand.Reader, b[:]) if err != nil { panic(fmt.Errorf(\"cannot initialize objectid package with crypto.rand.Reader: %v\", err)) } return (uint32(b[0]) \u003c\u003c 0) | (uint32(b[1]) \u003c\u003c 8) | (uint32(b[2]) \u003c\u003c 16) | (uint32(b[3]) \u003c\u003c 24) } # python版本 https://github.com/mongodb/mongo-python-driver/blob/master/bson/objectid.py # python 使用 os.urandom 生成随机数, os.urandom 跟 go 的类似，使用/dev/urandom 或者 系统提供的 api # os.urandom() method is used to generate a string of size random bytes suitable for cryptographic use or we can say this method generates a string containing random characters. ... def _random_bytes(): \"\"\"Get the 5-byte random field of an ObjectId.\"\"\" return os.urandom(5) class ObjectId(object): \"\"\"A MongoDB ObjectId. \"\"\" _pid = os.getpid() _inc = SystemRandom().randint(0, _MAX_COUNTER_VALUE) _inc_lock = threading.Lock() __random = _random_bytes() ... ","date":"2021-07-15","objectID":"/2021-07-14-by-talk-of-mongodb/:2:2","tags":["MongoDB"],"title":"MongoDB杂谈","uri":"/2021-07-14-by-talk-of-mongodb/"},{"categories":null,"content":"2.3 真的唯一吗 作为一个唯一ID生成方案，ObjectId 真的100%唯一吗？ 从实现方案本身分析： 当一个进程一秒内生成超过 2^24 个 ObjectId，counter会溢出，得到重复 id 机器识别码重复，在一定的时空条件下，在同样的时间戳和couter下生成重复的id 一些年久失修的第三方driver错误的实现可能导致一定条件下产生重复id 第1点出现的前提条件达成的概率，毕竟普通服务器单进程千万级别写入/s，cpu要冒烟了。 第2点达成的条件也比较苛刻，但是出现了就真的是，走鬼，见到运了。 第3点比较容易避免，使用官方driver和较新的MongoDB即可。 总的来说，ObjectId 能保证数据库级别的唯一性（不同collection之间），至于系统级的唯一性需要一些防御性的措施做保证。 ","date":"2021-07-15","objectID":"/2021-07-14-by-talk-of-mongodb/:2:3","tags":["MongoDB"],"title":"MongoDB杂谈","uri":"/2021-07-14-by-talk-of-mongodb/"},{"categories":null,"content":"2.4 其他唯一ID生成方案 常见的方案由UUID、SnowFlake等，各有优劣，篇幅有限不展开细说，可查看https://segmentfault.com/a/1190000020993874 ","date":"2021-07-15","objectID":"/2021-07-14-by-talk-of-mongodb/:2:4","tags":["MongoDB"],"title":"MongoDB杂谈","uri":"/2021-07-14-by-talk-of-mongodb/"},{"categories":null,"content":"3 TTL索引 TTL indexes are special single-field indexes that MongoDB can use to automatically remove documents from a collection after a certain amount of time or at a specific clock time. Data expiration is useful for certain types of information like machine generated event data, logs, and session information that only need to persist in a database for a finite amount of time. 文档传送门 TTL全称是(Time To Live),TTL索引能对一个单列配置过期属性来实现对文档的自动过期删除，我们可以在对字段创建索引时添加expireAfterSeconds选项将索引转换为TTL索引，该字段需要是date类型，在以下几种场景下即使索引设置了expireAfterSeconds属性也不会生效 - 如果该字段不是date类型，则文档不会过期 - 如果文档没包含索引的这个字段，则文档不会过期 # 创建TTL索引 db.yourdb.createIndex( { \"fieldKey\": 1 }, { expireAfterSeconds: 3600 } ) 一次偶然的机会，跑了一个driver的测试用例，发现里面有个检查TTL功能的用例，把 expireAfterSeconds 设置成 1，然后开定时器等待几秒后，执行一个assert # 伪代码 db.yourdb.createIndex( { \"fieldKey\": 1 }, { expireAfterSeconds: 1 } ) db.yourdb.insert({\"fieldKey\": \"hehe\"}) sleep(5) assert(db.yourdb.findOne({\"fieldKey\": \"hehe\"}) == null) 然而assert失败了，文档还存在，打开 Mongo 客户端上去一看发现确实还在，但是过了一段时间后文档就被删除了。 似乎 MongoDB 是按一定周期去检测、删除过期文档的。 带着疑问，去扒了一下 MongoDB 的源码。 // https://github.com/mongodb/mongo/blob/master/src/mongo/db/ttl.cpp ... class TTLMonitor : public BackgroundJob { void run() { { // Wait until either ttlMonitorSleepSecs passes or a shutdown is requested. auto deadline = Date_t::now() + Seconds(ttlMonitorSleepSecs.load()); stdx::unique_lock\u003cLatch\u003e lk(_stateMutex); MONGO_IDLE_THREAD_BLOCK; _shuttingDownCV.wait_until( lk, deadline.toSystemTimePoint(), [\u0026] { return _shuttingDown; }); if (_shuttingDown) { return; } } ... doTTLPass(); ... } /** * Gets all TTL specifications for every collection and deletes expired documents. */ void doTTLPass() { ... } } ... MongoDB起了一个后台线程，每间隔 ttlMonitorSleepSecs 这段之间检测一次过期的文档并删除，通过搜索 MongoDB 的代码和实测，这个值默认为60秒。 改变ttlMonitorSleepSecs As of today, it’s not possible, but already tracked in MongoDB JIRA: SERVER-6712: Make TTL Collection background task period user defined (command line option) SERVER-8616: Adding Tunable to TTL Collection thread SERVER-13937: Allow setting a window and interval for the TTL monitor There’s also kind of a workaround - you can turn TTL monitor off and on manually: db.adminCommand({setParameter: 1, ttlMonitorEnabled: false}); db.adminCommand({setParameter: 1, ttlMonitorEnabled: true}); EDIT: It turned out, that there is a ttlMonitorSleepSecs flag. It’s mentioned for example here, but it’s not mentioned in the official docs. db.adminCommand({setParameter: 1, ttlMonitorSleepSecs: 60}); 原文地址 ","date":"2021-07-15","objectID":"/2021-07-14-by-talk-of-mongodb/:3:0","tags":["MongoDB"],"title":"MongoDB杂谈","uri":"/2021-07-14-by-talk-of-mongodb/"},{"categories":null,"content":"4 MongoDB Wire Protocol MongoDB Wire Protocol 是一个简单的基于套接字的请求-响应样式协议。Client 端通过常规的 TCP/IP 套接字与数据库服务器通信。 Client 端应使用常规的 TCP/IP 套接字连接到数据库，所有整数都使用低位字节序：即，最低有效字节在前。 协议的消息头 struct MsgHeader { int32 messageLength; // 消息的总长度，包括这个字段本身 int32 requestID; // 请求的标识id，同一个客户端，每次请求都生成一个唯一id int32 responseTo; // 原始的requestID，回复给客户端，客户端用于处理请求回复 int32 opCode; // 请求的类型，不同的类型对应不同的消息体 } opCode的类型： Opcode Name Value Comment OP_MSG 2013 Send a message using the format introduced in MongoDB 3.6. OP_REPLYDeprecated in MongoDB 5.0. 1 Reply to a client request. responseTo is set. OP_UPDATEDeprecated in MongoDB 5.0. 2001 Update document. OP_INSERTDeprecated in MongoDB 5.0. 2002 Insert new document. RESERVED 2003 Formerly used for OP_GET_BY_OID. OP_QUERYDeprecated in MongoDB 5.0. 2004 Query a collection. OP_GET_MOREDeprecated in MongoDB 5.0. 2005 Get more data from a query. See Cursors. OP_DELETEDeprecated in MongoDB 5.0. 2006 Delete documents. OP_KILL_CURSORSDeprecated in MongoDB 5.0. 2007 Notify database that the client has finished with the cursor. OP_COMPRESSED 2012 Wraps other opcodes using compression 在较新版本的MongoDB中，很多请求类型都已经废弃，取而代之的是 OP_MSG (特性设计文档) OP_MSG is a bi-directional wire protocol opcode introduced in MongoDB 3.6 with the goal of replacing most existing opcodes, merging their use into one extendable opcode. 按文档的描述，OP_MSG 是一个更具拓展性的协议格式，用来取代现有的一些 opcodes，例如 OP_DELETE, OP_QUERY等。 OP_MSG { MsgHeader header; // standard message header uint32 flagBits; // message flags Sections[] sections; // data sections optional\u003cuint32\u003e checksum; // optional CRC-32C checksum } 篇幅有限，这里不详细展开，后续有空再开新坑扒一扒，这里先立个flag。 也是偶然的一次机会，跑了一次 driver 的测试用例，发现某些请求会出现奇奇怪怪的现象，比如请求没回复，排除了一下是MongoDB版本和driver版本对不上，新版本 MongoDB 废弃了某些协议，因此去扒了一下。 ","date":"2021-07-15","objectID":"/2021-07-14-by-talk-of-mongodb/:4:0","tags":["MongoDB"],"title":"MongoDB杂谈","uri":"/2021-07-14-by-talk-of-mongodb/"},{"categories":null,"content":"5 附录 MongoDB官方文档： https://docs.mongodb.com/manual/ MongoDB特性文档： https://github.com/mongodb/specifications 分布式唯一ID的几种生成方案： https://segmentfault.com/a/1190000020993874 stackoverflow： https://stackoverflow.com/questions/4677237/possibility-of-duplicate-mongo-objectids-being-generated-in-two-different-colle https://stackoverflow.com/questions/62118154/why-mongodb-java-driver-uses-random-bytes-instead-of-machine-id-in-objectid ","date":"2021-07-15","objectID":"/2021-07-14-by-talk-of-mongodb/:5:0","tags":["MongoDB"],"title":"MongoDB杂谈","uri":"/2021-07-14-by-talk-of-mongodb/"},{"categories":null,"content":"喂！三点几啦，饮茶先啦… 接着上一篇，这次要在树莓派上部署一下魔法。 大体的思路是在本地开启一个透明代理，通过iptables把某些神秘地址转发到透明代理，由透明代理发到一个跳板机器上。 由于使用了透明代理，本地的应用不知道有代理的存在，会提前进行dns解析，神秘地址会被定向到一些不存在的ip上，要想拿到正确的ip，神秘地址的dns解析请求要通过安全的方式进行，比如tls、https，可以使用cloudflare的dns服务器。 ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:0:0","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"准备 上一篇已经把dnsmasq装上了，这次剩下需要用到的工具安排上。 $ apt install ipset netfilter-persistent iptables-persistent ipset是iptables 的一个协助工具，用来维护特定的ip集合，iptables可以对这些集合进行屏蔽、转发。 netfilter-persistent、iptables-persistent主要用来持久化iptables规则和开机自动恢复。 ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:1:0","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"ipset 配置 ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:2:0","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"ipset作用 需要创建三个ipset：reserved、china、magic reserved: 保留地址，需要跳过发到这些地址的流量 china：大局域网内部所有地址，需要跳过发到这些地址的流量 maigc：跳板机的地址，需要跳过发到这些地址的流量 ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:2:1","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"ipset配置文件 创建 /etc/ipset.d目录，并创建ipset配置文件：reserved.conf，magic.conf，china.conf # /etc/ipset.d/reserved.conf create reserved hash:net family inet hashsize 256 maxelem 1024 add reserved 0.0.0.0/8 add reserved 10.0.0.0/8 add reserved 100.64.0.0/10 add reserved 127.0.0.0/8 add reserved 169.254.0.0/16 add reserved 172.16.0.0/12 add reserved 192.168.0.0/16 add reserved 224.0.0.0/4 add reserved 233.252.0.0/24 add reserved 240.0.0.0/4 # /etc/ipset.d/china.conf create magic hash:net family inet hashsize 128 maxelem 512 # 跳板机的地址 add magic xxx.xxx.xxx.xxx/32 add magic xxx.xxx.xxx.xxx/32 add magic xxx.xxx.xxx.xxx/32 通过IPdeny提供的整个国家的ip列表生成china.conf 先创建一个脚本 ~/cnipset.sh #!/bin/bash -e curl -O http://www.ipdeny.com/ipblocks/data/countries/cn.zone ipset_file=china.conf echo \"create china hash:net family inet hashsize 4096 maxelem 65536\" \u003e ${ipset_file} for i in $(cat ./cn.zone ); do echo \"add china ${i}\" \u003e\u003e ${ipset_file} done 执行脚本生成china.conf，再把china.conf拷贝到/etc/ipset.d/china.conf 遍历/etc/ipset.d下的文件，并创建ipset $ for f in `find /etc/ipset.d -type f`; do ipset restore -exist -file $f; done ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:2:2","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"开机自动恢复ipset 创建systemd服务， 重启后自动恢复ipset，注意ipset-persistent需要在netfilter-persistent之前启动 # /etc/systemd/system/ipset-persistent.service [Unit] Description=ipset persistent configuration Before=network.target # ipset sets should be loaded before iptables # Because creating iptables rules with names of non-existent sets is not possible Before=netfilter-persistent.service # ConditionFileNotEmpty=/etc/ipset.conf ConditionDirectoryNotEmpty=/etc/ipset.d [Service] Type=oneshot RemainAfterExit=yes ExecStart=/bin/sh -c \"for f in `find /etc/ipset.d -type f`; do ipset restore -exist -file $f; done\" [Install] WantedBy=multi-user.target RequiredBy=netfilter-persistent.service 启动服务 $ systemctl enable ipset-persistent ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:2:3","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"iptables配置 修改/etc/iptables/rules.v4 *filter :INPUT ACCEPT [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [0:0] COMMIT *nat :PREROUTING ACCEPT [0:0] :INPUT ACCEPT [0:0] :OUTPUT ACCEPT [0:0] :POSTROUTING ACCEPT [0:0] :MAGIC - [0:0] -A OUTPUT -j MAGIC -A PREROUTING -j MAGIC -A POSTROUTING -s 172.17.0.0/16 ! -o brlan -j MASQUERADE # 跳过跳板机的地址集合 -A MAGIC -m set --match-set magic dst -j RETURN # 跳过保留地址集合 -A MAGIC -m set --match-set reserved dst -j RETURN # 跳过大局域网地址集合 -A MAGIC -p tcp -m set --match-set china dst -j RETURN # 其他tcp请求都转发到透明代理端口 -A MAGIC -p tcp -j REDIRECT --to-port 12345 COMMIT 重启netfilter-persistent $ systemctl restart iptables ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:3:0","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"配置dnsmasq 本地先用工具启动一个dns代理工具，监听1053端口，把通过该端口的dns请求转发到1.1.1.1:853/tls上，去往1.1.1.1这个ip的流量会由iptables转发到透明代理上，实际上最终的dns请求会由跳板机完成。 基础配置 /etc/dnsmasq.d/dns.conf，屏蔽resolv.conf提供的dns服务器，上游dns服务器设置为腾讯云公共dns no-resolv all-servers cache-size=4096 clear-on-reload server=119.29.29.29 server=223.5.5.5 某黑名单的域名使用本地1053端口的dns接管，可过工具生成 /etc/dnsmasq.d/gfwlist.conf server=/about.google/127.0.0.1#1053 server=/aboutgfw.com/127.0.0.1#1053 server=/abs.edu/127.0.0.1#1053 server=/ac.jiruan.net/127.0.0.1#1053 ... 重启dnsmasq $ systemctl restart dnsmasq ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:4:0","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"透明代理 本地透明代理和dns代理自行实现或使用某现成工具，不多BB，自求多福吧。 ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:5:0","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"概述 印度养蛊，传进来了… 由于疫情宅在家，闲来无事折腾下手上的树莓派4B，先用hostapd + dnsmasq搭一个热点，后面再把一些魔法搞起来。 ","date":"2021-05-30","objectID":"/2021-05-30-rpi-wifi/:1:0","tags":["hostapd","树莓派","raspberry pi"],"title":"树莓派折腾笔记：开启WiFi热点","uri":"/2021-05-30-rpi-wifi/"},{"categories":null,"content":"准备 之前已经给rpi装了ubuntu server 20.04，现在把一些软件装上。 # apt install hostapd dnsmasq ","date":"2021-05-30","objectID":"/2021-05-30-rpi-wifi/:2:0","tags":["hostapd","树莓派","raspberry pi"],"title":"树莓派折腾笔记：开启WiFi热点","uri":"/2021-05-30-rpi-wifi/"},{"categories":null,"content":"增加网桥 以桥接的方式接入树莓派的无线网卡wlan0。 ubuntu server 20.04可以通过netplan修改网络配置，netplan是基于systemd-networkd的，没有netplan可以直接修改systemd-networkd配置。非systemd的系统自行使用bridge-utils自行增加网桥。 修改/etc/netplan/50-cloud-init.yaml文件 network: ethernets: eth0: dhcp4: true optional: true bridges: brlan: dhcp4: false addresses: [ 172.17.0.1/24 ] version: 2 新增bridges这段配置，网桥名字为brlan，关掉dhcp，改成静态地址172.17.0.1/24。 ","date":"2021-05-30","objectID":"/2021-05-30-rpi-wifi/:3:0","tags":["hostapd","树莓派","raspberry pi"],"title":"树莓派折腾笔记：开启WiFi热点","uri":"/2021-05-30-rpi-wifi/"},{"categories":null,"content":"hostapd配置 修改/etc/hostapd/hostapd.conf interface=wlan0 # 指定网卡 bridge=brlan # 桥接到brlan ssid=[wifi名称] macaddr_acl=0 ignore_broadcast_ssid=0 auth_algs=1 wpa=2 wpa_passphrase=[wifi密码] wpa_key_mgmt=WPA-PSK wpa_pairwise=TKIP rsn_pairwise=CCMP ## 5G (树莓派的无线网卡过于辣鸡，5G隔墙就没了，还是开2.4G吧) # hw_mode=a # channel=149 # country_code=CN # ieee80211d=1 # ieee80211ac=1 # wmm_enabled=1 ## 2.4G hw_mode=g channel=11 ieee80211n=1 ","date":"2021-05-30","objectID":"/2021-05-30-rpi-wifi/:4:0","tags":["hostapd","树莓派","raspberry pi"],"title":"树莓派折腾笔记：开启WiFi热点","uri":"/2021-05-30-rpi-wifi/"},{"categories":null,"content":"dnsmasq配置 增加一个配置文件 /etc/dnsmasq.d/hostapd.conf interface=brlan # 指定dhcp的接口为网桥 dhcp-range=172.17.0.100,172.17.0.250,255.255.255.0,12h # 动态ip范围 dhcp-option=3,172.17.0.1 # 网关是网桥的地址 ","date":"2021-05-30","objectID":"/2021-05-30-rpi-wifi/:5:0","tags":["hostapd","树莓派","raspberry pi"],"title":"树莓派折腾笔记：开启WiFi热点","uri":"/2021-05-30-rpi-wifi/"},{"categories":null,"content":"运行 开机启动 # systemctl enable dnsmasq # systemctl enable hostapd 重启服务，刷新配置 # systemctl restart dnsmasq # systemctl restart hostapd 查看日志 # journalctl -f -u hostapd May 30 10:35:31 rpi-4b systemd[1]: Starting Advanced IEEE 802.11 AP and IEEE 802.1X/WPA/WPA2/EAP Authenticator... May 30 10:35:32 rpi-4b hostapd[1683]: Configuration file: /etc/hostapd/hostapd.conf May 30 10:35:32 rpi-4b hostapd[1683]: Using interface wlan0 with hwaddr e4:5f:01:20:e2:dd and ssid \"[wifi名称]\" May 30 10:35:32 rpi-4b hostapd[1683]: wlan0: interface state UNINITIALIZED-\u003eENABLED May 30 10:35:32 rpi-4b hostapd[1683]: wlan0: AP-ENABLED May 30 10:35:32 rpi-4b systemd[1]: Started Advanced IEEE 802.11 AP and IEEE 802.1X/WPA/WPA2/EAP Authenticator. 没报错，且能见到这一行，基本就ojbk了 Using interface wlan0 with hwaddr e4:5f:01:20:e2:dd and ssid xxx ","date":"2021-05-30","objectID":"/2021-05-30-rpi-wifi/:6:0","tags":["hostapd","树莓派","raspberry pi"],"title":"树莓派折腾笔记：开启WiFi热点","uri":"/2021-05-30-rpi-wifi/"},{"categories":null,"content":"安装依赖 自带的dnsmasq 不支持 ipset，需要安装 dnsmasq-full 才能支持所有功能，安装前先删除原来的 dnsmasq $ opkg install dnsmasq-full ipset ","date":"2021-05-05","objectID":"/2021-05-05-openwrt-dns-configuration/:1:0","tags":["openwrt"],"title":"openwrt dns 配置","uri":"/2021-05-05-openwrt-dns-configuration/"},{"categories":null,"content":"配置dnsmasq 创建 dnsmasq.d 目录 $ mkdir /etc/dnsmasq.d 在 /etc/dnsmasq.conf 末尾增加 conf-dir ... # include /etc/dnsmasq.d conf-dir=/etc/dnsmasq.d/,*.conf ","date":"2021-05-05","objectID":"/2021-05-05-openwrt-dns-configuration/:2:0","tags":["openwrt"],"title":"openwrt dns 配置","uri":"/2021-05-05-openwrt-dns-configuration/"},{"categories":null,"content":"配置 DNS 服务器 新建文件/etc/dnsmasq.d/dns.conf # ignore /etc/resolv.conf no-resolv server=119.29.29.29 server=223.5.5.5 ","date":"2021-05-05","objectID":"/2021-05-05-openwrt-dns-configuration/:3:0","tags":["openwrt"],"title":"openwrt dns 配置","uri":"/2021-05-05-openwrt-dns-configuration/"},{"categories":null,"content":"ipset 配置 dnsmasq 在 2.66 版之后加入了对 ipset 的支持，可将指定域名的 IP 解析后自动加入某一 ipset 中，可以结合魔法使用。 通过工具生成 dnsmasq 转换 ipset 规则：传送门 生成文件放到/etc/dnsmasq.d/xxx.conf 由于上面已经配置好了一个相对可靠的 dns 服务器，xxx.conf 中可以去掉针对特定域名的配置特定的 dns 服务器 # 仅保留 ipset 配置 $ cat /etc/dnsmasq.d/xxx.conf | grep ipset \u003e /etc/dnsmasq.d/xxx.conf /etc/rc.local ... # 启动后自动创建xxx集合 ipset create xxx hash:ip ","date":"2021-05-05","objectID":"/2021-05-05-openwrt-dns-configuration/:4:0","tags":["openwrt"],"title":"openwrt dns 配置","uri":"/2021-05-05-openwrt-dns-configuration/"},{"categories":null,"content":"最后 重启 dnsmasq $ /etc/init.d/dnsmasq restart 测试域名解析 $ nslookup openwrt.org ","date":"2021-05-05","objectID":"/2021-05-05-openwrt-dns-configuration/:5:0","tags":["openwrt"],"title":"openwrt dns 配置","uri":"/2021-05-05-openwrt-dns-configuration/"},{"categories":null,"content":"五一假期不想出去看人山人海，宅在家中，闲来无事更新家里的Netgear R6850路由器的OpenWrt。 之前已经把路由器刷成OpenWrt固件了，但是当时官方尚未正式支持R6850，所以动手制作了一个snapshot镜像，并刷到机器上。 最近看到openwrt-21.02.0-rc1已经正式支持R6850了（虽然是rc版本……），so…搞起来。 1 制作固件 ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:0:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"1.1 环境搭建 由于编译太耗时了，因此选择Image Builder来制作镜像。具体可参照 官方文档。 为了简化环境搭建、方便后续更新，把Image builder的运行环境封装在Docker镜像中，在Docker中构建OpenWrt镜像 上次刷OpenWrt的时候已经封装了一些脚本，源码放在lchannng/openwrt-builder。 # openwrt-builder/DockerfileFROMdebian:buster-slimMAINTAINERlchannng \u003clchannng@gmail.com\u003eRUN apt-get update -qq \u0026\u0026\\ apt-get install -y \\ build-essential \\ curl \\ file \\ gawk \\ gettext \\ git \\ libncurses5-dev \\ libssl-dev \\ python2.7 \\ python3 \\ rsync \\ subversion \\ sudo \\ swig \\ unzip \\ wget \\ zlib1g-dev \\ \u0026\u0026 apt-get -y autoremove \\ \u0026\u0026 apt-get clean \\ \u0026\u0026 rm -rf /var/lib/apt/lists/*RUN echo '%sudo ALL=(ALL) NOPASSWD:ALL' \u003e\u003e /etc/sudoersRUN useradd -c \"OpenWrt Builder\" -m -d /home/build -G sudo -s /bin/bash buildCOPY --chown=build:build ./openwrt/ /home/build/openwrt/RUN chown build:build /home/build/openwrt/USERbuildENV HOME /home/buildWORKDIR/home/build/openwrt #!/bin/bash # File : prepare.sh # Author: lchannng \u003cl.channng@gmail.com\u003e # Date : 2020/08/18 19:24:13 TAG=ijk/openwrt-builder OPENWRT_ARCH=\"${OPENWRT_ARCH:-ramips}\" OPENWRT_HOST=\"${OPENWRT_HOST:-Linux-x86_64}\" OPENWRT_TARGET=\"${OPENWRT_TARGET:-mt7621}\" OPENWRT_VERSION=\"${OPENWRT_VERSION:-19.07.3}\" BUILDER_NAME=\"openwrt-imagebuilder-${OPENWRT_VERSION}-${OPENWRT_ARCH}-${OPENWRT_TARGET}.${OPENWRT_HOST}\" BUILDER_URL=\"https://downloads.openwrt.org/releases/${OPENWRT_VERSION}/targets/${OPENWRT_ARCH}/${OPENWRT_TARGET}/${BUILDER_NAME}.tar.xz\" if [ ! -f ${BUILDER_NAME}.tar.xz ]; then echo \"downloading ${BUILDER_URL}...\" \u0026\u0026 \\ curl ${BUILDER_URL} -o ${BUILDER_NAME}.tar.xz \u0026\u0026 \\ tar xvf ${BUILDER_NAME}.tar.xz fi ln -snf ${BUILDER_NAME} openwrt docker build -t ${TAG} . 这两个脚本做的事情很简单，仅仅是把我们需要的版本下载回来，并解压到 openwrt 目录，构建Docker镜像的时候，把 openwrt 目录拷贝到镜像的 /home/build/openwrt 目录。 ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:1:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"1.2 构建 Docker 镜像 把 openwrt-builder 拉下来后，修改 build.sh 中填写的 OpenWrt 架构、版本等信息。 本次使用 openwrt-21.02.0-rc1，修改 OPENWRT_VERSION 如下： OPENWRT_VERSION=\"${OPENWRT_VERSION:-21.02.0-rc1}\" 修改完毕后，无脑执行 build.sh 构建 Docker 镜像，完成后可得镜像 ijk/openwrt-builder。 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ijk/openwrt-builder latest 2f82e3b0ca31 20 hours ago 919MB ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:2:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"1.3 制作 OpenWrt 镜像 启动Image Builder $ docker run -it -v ~/openwrt-builder/bin:/home/build/openwrt/bin ijk/openwrt-builder 这里把宿主机的~/openwrt-builder/bin映射到Docker容器的/home/build/openwrt/bin目录，这个目录是 OpenWrt 镜像的输出目录。 构建镜像, PROFILE选择\"netgear_R6850\"，额外的包只增加luci。 $ cd /home/build/openwrt $ make image PROFILE=\"netgear_R6850\" PACKAGES=\"luci\" 如无意外，等待几分钟后，在 /home/build/openwrt/bin/targets (宿主机下的 ~/openwrt-builder/bin/targets 目录) 中可以找到成功输出的镜像。 $ ls -R /home/build/openwrt/bin/targets/ /home/build/openwrt/bin/targets/: ramips /home/build/openwrt/bin/targets/ramips: mt7621 /home/build/openwrt/bin/targets/ramips/mt7621: openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850-squashfs-factory.img openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850-squashfs-kernel.bin openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850-squashfs-rootfs.bin openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850-squashfs-sysupgrade.bin openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850.manifest profiles.json sha256sums 2 刷机 ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:3:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"2.1 从官方固件刷到 OpenWrt 如果路由器还是 Netgear 官方固件，可以登陆管理页面，通过管理页面的更新固件入口，上传 OpenWrt 固件进行更新。比较无脑，不做详细描述。等待几分钟后，通过网线连接 lan 口尝试连接路由器并登陆 192.168.1.1 进行配置。 ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:4:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"2.2 从 OpenWrt 刷 OpenWrt 如果路由器还能登陆到管理页面，可以在 System - Backup / Flash firmware 来进行刷机。 此外可以通过 nmrpflash 进行刷机。 nmrpflash uses Netgear’s NMRP protocol to flash a new firmware image to a compatible device. It has been successfully used on a Netgear EX2700, EX6100v2, EX6120, EX6150v2, DNG3700v2, R6100, R6220, R7000, D7000, WNR3500, R6080, R6400 and R6800, R8000, R8500, WNDR3800, but is likely to be compatible with many other Netgear devices. 具体操作如下： 拔掉所有无关网线、无线网卡 使用网线连接到路由器 lan 口 将连接路由器的网卡 ip 设置为 192.168.1.2，子网掩码为255.255.255.0，默认网关 192.168.1.1 (网上大多数教程都是这么说的，暂时没看到官方资料有相关描述，但是不这么设置貌似刷不了机) 关闭路由器电源 运行 nmrpflash -i -f \u003copenwrt-xxx.img\u003e 打开路由器电源，等待路由器 NMRP 握手并执行更新，如果一直连不上，重复 4 - 6 步骤 # 查看网络接口 $ nmrpflash -L eth0 192.168.1.2 33:c6:47:28:70:95 # 运行nmrpflash，指定网口和OpenWrt镜像 $ nmrpflash -i eth0 -f openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850-squashfs-factory.img Waiting for physical connection. Advertising NMRP server on net14 ... / Received configuration request from 78:d2:94:81:6a:cf. Sending configuration: 10.164.183.252/24. Received upload request without filename. Uploading openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850-squashfs-factory.img ... OK Waiting for remote to respond. Received keep-alive request (2). Remote finished. Closing connection. Reboot your device now. 等待几分钟，直到出现”Reboot your device now.“ 后，重启路由器，并使用网线连接到路由器 lan 口，登陆 192.168.1.1 设置路由器。 ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:5:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"2.3 翻车自救 翻车嘛，在所难免…… 翻车不可怕，只要nmrp没坏，还是有救的，具体可参照 2.2 中 nmrpflash 刷机步骤进行重刷。 也可以通过 nmrpflash 重新刷回官方固件(辣鸡官方固件，应该没人会刷回去……)。 3 OpenWrt 后续配置 ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:6:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"3.1 修改默认Lan IP openwrt 默认lan IP 是 192.168.1.1，与光猫冲突了，改成别的地址 ssh到路由器 $ uci set network.lan.ipaddr=192.168.111.1 $ uci commit \u0026\u0026 service network restart ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:7:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"3.2 SSH 密钥登陆 参考官方文档 Dropbear key-based authentication root用户需要把公钥放到 /etc/dropbear/authorized_keys ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:8:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"3.3 privoxy 配置 # /etc/config/privoxy config privoxy 'privoxy' option confdir '/etc/privoxy' option logdir '/var/log' option logfile 'privoxy.log' list listen_address '192.168.111.1:8118' option forward_socks5 '/ 192.168.111.1:65530 .' ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:9:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"3.4 出国留学 使用自用的magic协议，这里不可描述，略过。 此外还要配置pac文件。 使用工具生产pac文件，代理地址为PROXY 192.168.111.1:8118，并把该文件放到路由器的/www/xxx.pac 在手机上把pac地址配置为 http://192.168.111.1/xxx.pac ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:10:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"官方blog传送门：https://blog.golang.org/defer-panic-and-recover ","date":"2019-05-16","objectID":"/2019-05-16-go-defer-panic-recover/:0:0","tags":["golang","备忘"],"title":"go笔记 defer,panic,recover","uri":"/2019-05-16-go-defer-panic-recover/"},{"categories":null,"content":"defer A defer statement pushes a function call onto a list. The list of saved calls is executed after the surrounding function returns. Defer is commonly used to simplify functions that perform various clean-up actions. defer类似cpp在对象在离开作用于后析构，defer可以多次，这样形成一个defer栈，后defer的语句在函数返回时将先被调用。 func CopyFile(dstName, srcName string) (written int64, err error) { src, err := os.Open(srcName) if err != nil { return } defer src.Close() dst, err := os.Create(dstName) if err != nil { return } defer dst.Close() return io.Copy(dst, src) } ","date":"2019-05-16","objectID":"/2019-05-16-go-defer-panic-recover/:1:0","tags":["golang","备忘"],"title":"go笔记 defer,panic,recover","uri":"/2019-05-16-go-defer-panic-recover/"},{"categories":null,"content":"panic Panic is a built-in function that stops the ordinary flow of control and begins panicking. When the function F calls panic, execution of F stops, any deferred functions in F are executed normally, and then F returns to its caller. To the caller, F then behaves like a call to panic. The process continues up the stack until all functions in the current goroutine have returned, at which point the program crashes. Panics can be initiated by invoking panic directly. They can also be caused by runtime errors, such as out-of-bounds array accesses. 执行panic后，函数不在往下走，会调用defer package main import ( \"fmt\" ) func main() { defer_call() } func defer_call() { defer func() { fmt.Println(\"111\") }() defer func() { fmt.Println(\"222\") }() defer func() { fmt.Println(\"333\") }() panic(\"panic\") } /* 输出: 333 222 111 panic: panic goroutine 1 [running]: main.defer_call() C:/Users/lch/go/src/github.com/lchannng/gopl/defer/main.go:21 +0x98 main.main() C:/Users/lch/go/src/github.com/lchannng/gopl/defer/main.go:14 +0x27 */ ","date":"2019-05-16","objectID":"/2019-05-16-go-defer-panic-recover/:2:0","tags":["golang","备忘"],"title":"go笔记 defer,panic,recover","uri":"/2019-05-16-go-defer-panic-recover/"},{"categories":null,"content":"recover Recover is a built-in function that regains control of a panicking goroutine. Recover is only useful inside deferred functions. During normal execution, a call to recover will return nil and have no other effect. If the current goroutine is panicking, a call to recover will capture the value given to panic and resume normal execution. 按上面所说，panic的函数并不会立刻返回，而是先defer，再返回。这时候可在defer中将panic捕获到，并阻止panic传递，save the world。 一个类似try catch的例子 func Try(f func(), handler func(interface{}) { defer func() { if err := recover(); err != nil { handler(err) } } f() }) func main() { Try(func() { panic(\"oh!panic.\") }, func(e interface{}) { fmt.Println(e) }) } ","date":"2019-05-16","objectID":"/2019-05-16-go-defer-panic-recover/:3:0","tags":["golang","备忘"],"title":"go笔记 defer,panic,recover","uri":"/2019-05-16-go-defer-panic-recover/"},{"categories":null,"content":"文档传送门(https://dev.mysql.com/doc/refman/8.0/en/windows-installation.html) 从noinstall ZIP Archive安装 初始化data目录 mysqld --initialize --console 登录, 输入随机生成的密码 mysql -u root -p 修改密码 ALTER USER 'root'@'localhost' IDENTIFIED BY 'your-password'; ","date":"2019-05-14","objectID":"/2019-05-14-installing-mysql-on-windows/:0:0","tags":["备忘","mysql"],"title":"Windows下安装mysql","uri":"/2019-05-14-installing-mysql-on-windows/"}]