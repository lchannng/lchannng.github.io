[{"categories":null,"content":"喂！三点几啦，饮茶先啦… 接着上一篇，这次要在树莓派上部署一下魔法。 大体的思路是在本地开启一个透明代理，通过iptables把某些神秘地址转发到透明代理，由透明代理发到一个跳板机器上。 由于使用了透明代理，本地的应用不知道有代理的存在，会提前进行dns解析，神秘地址会被定向到一些不存在的ip上，要想拿到正确的ip，神秘地址的dns解析请求要通过安全的方式进行，比如tls、https，可以使用cloudflare的dns服务器。 ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:0:0","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"准备 上一篇已经把dnsmasq装上了，这次剩下需要用到的工具安排上。 $ apt install ipset netfilter-persistent iptables-persistent ipset是iptables 的一个协助工具，用来维护特定的ip集合，iptables可以对这些集合进行屏蔽、转发。 netfilter-persistent、iptables-persistent主要用来持久化iptables规则和开机自动恢复。 ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:1:0","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"ipset 配置 ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:2:0","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"ipset作用 需要创建三个ipset：reserved、china、magic reserved: 保留地址，需要跳过发到这些地址的流量 china：大局域网内部所有地址，需要跳过发到这些地址的流量 maigc：跳板机的地址，需要跳过发到这些地址的流量 ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:2:1","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"ipset配置文件 创建 /etc/ipset.d目录，并创建ipset配置文件：reserved.conf，magic.conf，china.conf # /etc/ipset.d/reserved.conf create reserved hash:net family inet hashsize 256 maxelem 1024 add reserved 0.0.0.0/8 add reserved 10.0.0.0/8 add reserved 100.64.0.0/10 add reserved 127.0.0.0/8 add reserved 169.254.0.0/16 add reserved 172.16.0.0/12 add reserved 192.168.0.0/16 add reserved 224.0.0.0/4 add reserved 233.252.0.0/24 add reserved 240.0.0.0/4 # /etc/ipset.d/china.conf create magic hash:net family inet hashsize 128 maxelem 512 # 跳板机的地址 add magic xxx.xxx.xxx.xxx/32 add magic xxx.xxx.xxx.xxx/32 add magic xxx.xxx.xxx.xxx/32 通过IPdeny提供的整个国家的ip列表生成china.conf 先创建一个脚本 ~/cnipset.sh #!/bin/bash -e curl -O http://www.ipdeny.com/ipblocks/data/countries/cn.zone ipset_file=china.conf echo \"create china hash:net family inet hashsize 4096 maxelem 65536\" \u003e ${ipset_file} for i in $(cat ./cn.zone ); do echo \"add china ${i}\" \u003e\u003e ${ipset_file} done 执行脚本生成china.conf，再把china.conf拷贝到/etc/ipset.d/china.conf 遍历/etc/ipset.d下的文件，并创建ipset $ for f in `find /etc/ipset.d -type f`; do ipset restore -exist -file $f; done ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:2:2","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"开机自动恢复ipset 创建systemd服务， 重启后自动恢复ipset，注意ipset-persistent需要在netfilter-persistent之前启动 # /etc/systemd/system/ipset-persistent.service [Unit] Description=ipset persistent configuration Before=network.target # ipset sets should be loaded before iptables # Because creating iptables rules with names of non-existent sets is not possible Before=netfilter-persistent.service # ConditionFileNotEmpty=/etc/ipset.conf ConditionDirectoryNotEmpty=/etc/ipset.d [Service] Type=oneshot RemainAfterExit=yes ExecStart=/bin/sh -c \"for f in `find /etc/ipset.d -type f`; do ipset restore -exist -file $f; done\" [Install] WantedBy=multi-user.target RequiredBy=netfilter-persistent.service 启动服务 $ systemctl enable ipset-persistent ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:2:3","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"iptables配置 修改/etc/iptables/rules.v4 *filter :INPUT ACCEPT [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [0:0] COMMIT *nat :PREROUTING ACCEPT [0:0] :INPUT ACCEPT [0:0] :OUTPUT ACCEPT [0:0] :POSTROUTING ACCEPT [0:0] :MAGIC - [0:0] -A OUTPUT -j MAGIC -A PREROUTING -j MAGIC -A POSTROUTING -s 172.17.0.0/16 ! -o brlan -j MASQUERADE # 跳过跳板机的地址集合 -A MAGIC -m set --match-set magic dst -j RETURN # 跳过保留地址集合 -A MAGIC -m set --match-set reserved dst -j RETURN # 跳过大局域网地址集合 -A MAGIC -p tcp -m set --match-set china dst -j RETURN # 其他tcp请求都转发到透明代理端口 -A MAGIC -p tcp -j REDIRECT --to-port 12345 COMMIT 重启netfilter-persistent $ systemctl restart iptables ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:3:0","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"配置dnsmasq 本地先用工具启动一个dns代理工具，监听1053端口，把通过该端口的dns请求转发到1.1.1.1:853/tls上，去往1.1.1.1这个ip的流量会由iptables转发到透明代理上，实际上最终的dns请求会由跳板机完成。 基础配置 /etc/dnsmasq.d/dns.conf，屏蔽resolv.conf提供的dns服务器，上游dns服务器设置为腾讯云公共dns no-resolv all-servers cache-size=4096 clear-on-reload server=119.29.29.29 server=223.5.5.5 某黑名单的域名使用本地1053端口的dns接管，可过工具生成 /etc/dnsmasq.d/gfwlist.conf server=/about.google/127.0.0.1#1053 server=/aboutgfw.com/127.0.0.1#1053 server=/abs.edu/127.0.0.1#1053 server=/ac.jiruan.net/127.0.0.1#1053 ... 重启dnsmasq $ systemctl restart dnsmasq ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:4:0","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"透明代理 本地透明代理和dns代理自行实现或使用某现成工具，不多BB，自求多福吧。 ","date":"2021-06-05","objectID":"/2021-06-05-rpi-magic/:5:0","tags":["iptables","dnsmasq","树莓派","raspberry pi","透明代理"],"title":"树莓派折腾笔记：通过iptables + dnsmasq + magic开启魔法","uri":"/2021-06-05-rpi-magic/"},{"categories":null,"content":"概述 印度养蛊，传进来了… 由于疫情宅在家，闲来无事折腾下手上的树莓派4B，先用hostapd + dnsmasq搭一个热点，后面再把一些魔法搞起来。 ","date":"2021-05-30","objectID":"/2021-05-30-rpi-wifi/:1:0","tags":["hostapd","树莓派","raspberry pi"],"title":"树莓派折腾笔记：开启WiFi热点","uri":"/2021-05-30-rpi-wifi/"},{"categories":null,"content":"准备 之前已经给rpi装了ubuntu server 20.04，现在把一些软件装上。 # apt install hostapd dnsmasq ","date":"2021-05-30","objectID":"/2021-05-30-rpi-wifi/:2:0","tags":["hostapd","树莓派","raspberry pi"],"title":"树莓派折腾笔记：开启WiFi热点","uri":"/2021-05-30-rpi-wifi/"},{"categories":null,"content":"增加网桥 以桥接的方式接入树莓派的无线网卡wlan0。 ubuntu server 20.04可以通过netplan修改网络配置，netplan是基于systemd-networkd的，没有netplan可以直接修改systemd-networkd配置。非systemd的系统自行使用bridge-utils自行增加网桥。 修改/etc/netplan/50-cloud-init.yaml文件 network: ethernets: eth0: dhcp4: true optional: true bridges: brlan: dhcp4: false addresses: [ 172.17.0.1/24 ] version: 2 新增bridges这段配置，网桥名字为brlan，关掉dhcp，改成静态地址172.17.0.1/24。 ","date":"2021-05-30","objectID":"/2021-05-30-rpi-wifi/:3:0","tags":["hostapd","树莓派","raspberry pi"],"title":"树莓派折腾笔记：开启WiFi热点","uri":"/2021-05-30-rpi-wifi/"},{"categories":null,"content":"hostapd配置 修改/etc/hostapd/hostapd.conf interface=wlan0 # 指定网卡 bridge=brlan # 桥接到brlan ssid=[wifi名称] macaddr_acl=0 ignore_broadcast_ssid=0 auth_algs=1 wpa=2 wpa_passphrase=[wifi密码] wpa_key_mgmt=WPA-PSK wpa_pairwise=TKIP rsn_pairwise=CCMP ## 5G (树莓派的无线网卡过于辣鸡，5G隔墙就没了，还是开2.4G吧) # hw_mode=a # channel=149 # country_code=CN # ieee80211d=1 # ieee80211ac=1 # wmm_enabled=1 ## 2.4G hw_mode=g channel=11 ieee80211n=1 ","date":"2021-05-30","objectID":"/2021-05-30-rpi-wifi/:4:0","tags":["hostapd","树莓派","raspberry pi"],"title":"树莓派折腾笔记：开启WiFi热点","uri":"/2021-05-30-rpi-wifi/"},{"categories":null,"content":"dnsmasq配置 增加一个配置文件 /etc/dnsmasq.d/hostapd.conf interface=brlan # 指定dhcp的接口为网桥 dhcp-range=172.17.0.100,172.17.0.250,255.255.255.0,12h # 动态ip范围 dhcp-option=3,172.17.0.1 # 网关是网桥的地址 ","date":"2021-05-30","objectID":"/2021-05-30-rpi-wifi/:5:0","tags":["hostapd","树莓派","raspberry pi"],"title":"树莓派折腾笔记：开启WiFi热点","uri":"/2021-05-30-rpi-wifi/"},{"categories":null,"content":"运行 开机启动 # systemctl enable dnsmasq # systemctl enable hostapd 重启服务，刷新配置 # systemctl restart dnsmasq # systemctl restart hostapd 查看日志 # journalctl -f -u hostapd May 30 10:35:31 rpi-4b systemd[1]: Starting Advanced IEEE 802.11 AP and IEEE 802.1X/WPA/WPA2/EAP Authenticator... May 30 10:35:32 rpi-4b hostapd[1683]: Configuration file: /etc/hostapd/hostapd.conf May 30 10:35:32 rpi-4b hostapd[1683]: Using interface wlan0 with hwaddr e4:5f:01:20:e2:dd and ssid \"[wifi名称]\" May 30 10:35:32 rpi-4b hostapd[1683]: wlan0: interface state UNINITIALIZED-\u003eENABLED May 30 10:35:32 rpi-4b hostapd[1683]: wlan0: AP-ENABLED May 30 10:35:32 rpi-4b systemd[1]: Started Advanced IEEE 802.11 AP and IEEE 802.1X/WPA/WPA2/EAP Authenticator. 没报错，且能见到这一行，基本就ojbk了 Using interface wlan0 with hwaddr e4:5f:01:20:e2:dd and ssid xxx ","date":"2021-05-30","objectID":"/2021-05-30-rpi-wifi/:6:0","tags":["hostapd","树莓派","raspberry pi"],"title":"树莓派折腾笔记：开启WiFi热点","uri":"/2021-05-30-rpi-wifi/"},{"categories":null,"content":"安装依赖 自带的dnsmasq 不支持 ipset，需要安装 dnsmasq-full 才能支持所有功能，安装前先删除原来的 dnsmasq $ opkg install dnsmasq-full ipset ","date":"2021-05-05","objectID":"/2021-05-05-openwrt-dns-configuration/:1:0","tags":["openwrt"],"title":"openwrt dns 配置","uri":"/2021-05-05-openwrt-dns-configuration/"},{"categories":null,"content":"配置dnsmasq 创建 dnsmasq.d 目录 $ mkdir /etc/dnsmasq.d 在 /etc/dnsmasq.conf 末尾增加 conf-dir ... # include /etc/dnsmasq.d conf-dir=/etc/dnsmasq.d/,*.conf ","date":"2021-05-05","objectID":"/2021-05-05-openwrt-dns-configuration/:2:0","tags":["openwrt"],"title":"openwrt dns 配置","uri":"/2021-05-05-openwrt-dns-configuration/"},{"categories":null,"content":"配置 DNS 服务器 新建文件/etc/dnsmasq.d/dns.conf # ignore /etc/resolv.conf no-resolv server=119.29.29.29 server=223.5.5.5 ","date":"2021-05-05","objectID":"/2021-05-05-openwrt-dns-configuration/:3:0","tags":["openwrt"],"title":"openwrt dns 配置","uri":"/2021-05-05-openwrt-dns-configuration/"},{"categories":null,"content":"ipset 配置 dnsmasq 在 2.66 版之后加入了对 ipset 的支持，可将指定域名的 IP 解析后自动加入某一 ipset 中，可以结合魔法使用。 通过工具生成 dnsmasq 转换 ipset 规则：传送门 生成文件放到/etc/dnsmasq.d/xxx.conf 由于上面已经配置好了一个相对可靠的 dns 服务器，xxx.conf 中可以去掉针对特定域名的配置特定的 dns 服务器 # 仅保留 ipset 配置 $ cat /etc/dnsmasq.d/xxx.conf | grep ipset \u003e /etc/dnsmasq.d/xxx.conf /etc/rc.local ... # 启动后自动创建xxx集合 ipset create xxx hash:ip ","date":"2021-05-05","objectID":"/2021-05-05-openwrt-dns-configuration/:4:0","tags":["openwrt"],"title":"openwrt dns 配置","uri":"/2021-05-05-openwrt-dns-configuration/"},{"categories":null,"content":"最后 重启 dnsmasq $ /etc/init.d/dnsmasq restart 测试域名解析 $ nslookup openwrt.org ","date":"2021-05-05","objectID":"/2021-05-05-openwrt-dns-configuration/:5:0","tags":["openwrt"],"title":"openwrt dns 配置","uri":"/2021-05-05-openwrt-dns-configuration/"},{"categories":null,"content":"五一假期不想出去看人山人海，宅在家中，闲来无事更新家里的Netgear R6850路由器的OpenWrt。 之前已经把路由器刷成OpenWrt固件了，但是当时官方尚未正式支持R6850，所以动手制作了一个snapshot镜像，并刷到机器上。 最近看到openwrt-21.02.0-rc1已经正式支持R6850了（虽然是rc版本……），so…搞起来。 1 制作固件 ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:0:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"1.1 环境搭建 由于编译太耗时了，因此选择Image Builder来制作镜像。具体可参照 官方文档。 为了简化环境搭建、方便后续更新，把Image builder的运行环境封装在Docker镜像中，在Docker中构建OpenWrt镜像 上次刷OpenWrt的时候已经封装了一些脚本，源码放在lchannng/openwrt-builder。 # openwrt-builder/DockerfileFROMdebian:buster-slimMAINTAINERlchannng \u003clchannng@gmail.com\u003eRUN apt-get update -qq \u0026\u0026\\ apt-get install -y \\ build-essential \\ curl \\ file \\ gawk \\ gettext \\ git \\ libncurses5-dev \\ libssl-dev \\ python2.7 \\ python3 \\ rsync \\ subversion \\ sudo \\ swig \\ unzip \\ wget \\ zlib1g-dev \\ \u0026\u0026 apt-get -y autoremove \\ \u0026\u0026 apt-get clean \\ \u0026\u0026 rm -rf /var/lib/apt/lists/*RUN echo '%sudo ALL=(ALL) NOPASSWD:ALL' \u003e\u003e /etc/sudoersRUN useradd -c \"OpenWrt Builder\" -m -d /home/build -G sudo -s /bin/bash buildCOPY --chown=build:build ./openwrt/ /home/build/openwrt/RUN chown build:build /home/build/openwrt/USERbuildENV HOME /home/buildWORKDIR/home/build/openwrt #!/bin/bash # File : prepare.sh # Author: lchannng \u003cl.channng@gmail.com\u003e # Date : 2020/08/18 19:24:13 TAG=ijk/openwrt-builder OPENWRT_ARCH=\"${OPENWRT_ARCH:-ramips}\" OPENWRT_HOST=\"${OPENWRT_HOST:-Linux-x86_64}\" OPENWRT_TARGET=\"${OPENWRT_TARGET:-mt7621}\" OPENWRT_VERSION=\"${OPENWRT_VERSION:-19.07.3}\" BUILDER_NAME=\"openwrt-imagebuilder-${OPENWRT_VERSION}-${OPENWRT_ARCH}-${OPENWRT_TARGET}.${OPENWRT_HOST}\" BUILDER_URL=\"https://downloads.openwrt.org/releases/${OPENWRT_VERSION}/targets/${OPENWRT_ARCH}/${OPENWRT_TARGET}/${BUILDER_NAME}.tar.xz\" if [ ! -f ${BUILDER_NAME}.tar.xz ]; then echo \"downloading ${BUILDER_URL}...\" \u0026\u0026 \\ curl ${BUILDER_URL} -o ${BUILDER_NAME}.tar.xz \u0026\u0026 \\ tar xvf ${BUILDER_NAME}.tar.xz fi ln -snf ${BUILDER_NAME} openwrt docker build -t ${TAG} . 这两个脚本做的事情很简单，仅仅是把我们需要的版本下载回来，并解压到 openwrt 目录，构建Docker镜像的时候，把 openwrt 目录拷贝到镜像的 /home/build/openwrt 目录。 ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:1:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"1.2 构建 Docker 镜像 把 openwrt-builder 拉下来后，修改 build.sh 中填写的 OpenWrt 架构、版本等信息。 本次使用 openwrt-21.02.0-rc1，修改 OPENWRT_VERSION 如下： OPENWRT_VERSION=\"${OPENWRT_VERSION:-21.02.0-rc1}\" 修改完毕后，无脑执行 build.sh 构建 Docker 镜像，完成后可得镜像 ijk/openwrt-builder。 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ijk/openwrt-builder latest 2f82e3b0ca31 20 hours ago 919MB ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:2:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"1.3 制作 OpenWrt 镜像 启动Image Builder $ docker run -it -v ~/openwrt-builder/bin:/home/build/openwrt/bin ijk/openwrt-builder 这里把宿主机的~/openwrt-builder/bin映射到Docker容器的/home/build/openwrt/bin目录，这个目录是 OpenWrt 镜像的输出目录。 构建镜像, PROFILE选择\"netgear_R6850\"，额外的包只增加luci。 $ cd /home/build/openwrt $ make image PROFILE=\"netgear_R6850\" PACKAGES=\"luci\" 如无意外，等待几分钟后，在 /home/build/openwrt/bin/targets (宿主机下的 ~/openwrt-builder/bin/targets 目录) 中可以找到成功输出的镜像。 $ ls -R /home/build/openwrt/bin/targets/ /home/build/openwrt/bin/targets/: ramips /home/build/openwrt/bin/targets/ramips: mt7621 /home/build/openwrt/bin/targets/ramips/mt7621: openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850-squashfs-factory.img openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850-squashfs-kernel.bin openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850-squashfs-rootfs.bin openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850-squashfs-sysupgrade.bin openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850.manifest profiles.json sha256sums 2 刷机 ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:3:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"2.1 从官方固件刷到 OpenWrt 如果路由器还是 Netgear 官方固件，可以登陆管理页面，通过管理页面的更新固件入口，上传 OpenWrt 固件进行更新。比较无脑，不做详细描述。等待几分钟后，通过网线连接 lan 口尝试连接路由器并登陆 192.168.1.1 进行配置。 ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:4:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"2.2 从 OpenWrt 刷 OpenWrt 如果路由器还能登陆到管理页面，可以在 System - Backup / Flash firmware 来进行刷机。 此外可以通过 nmrpflash 进行刷机。 nmrpflash uses Netgear’s NMRP protocol to flash a new firmware image to a compatible device. It has been successfully used on a Netgear EX2700, EX6100v2, EX6120, EX6150v2, DNG3700v2, R6100, R6220, R7000, D7000, WNR3500, R6080, R6400 and R6800, R8000, R8500, WNDR3800, but is likely to be compatible with many other Netgear devices. 具体操作如下： 拔掉所有无关网线、无线网卡 使用网线连接到路由器 lan 口 将连接路由器的网卡 ip 设置为 192.168.1.2，子网掩码为255.255.255.0，默认网关 192.168.1.1 (网上大多数教程都是这么说的，暂时没看到官方资料有相关描述，但是不这么设置貌似刷不了机) 关闭路由器电源 运行 nmrpflash -i -f \u003copenwrt-xxx.img\u003e 打开路由器电源，等待路由器 NMRP 握手并执行更新，如果一直连不上，重复 4 - 6 步骤 # 查看网络接口 $ nmrpflash -L eth0 192.168.1.2 33:c6:47:28:70:95 # 运行nmrpflash，指定网口和OpenWrt镜像 $ nmrpflash -i eth0 -f openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850-squashfs-factory.img Waiting for physical connection. Advertising NMRP server on net14 ... / Received configuration request from 78:d2:94:81:6a:cf. Sending configuration: 10.164.183.252/24. Received upload request without filename. Uploading openwrt-21.02.0-rc1-ramips-mt7621-netgear_r6850-squashfs-factory.img ... OK Waiting for remote to respond. Received keep-alive request (2). Remote finished. Closing connection. Reboot your device now. 等待几分钟，直到出现”Reboot your device now.“ 后，重启路由器，并使用网线连接到路由器 lan 口，登陆 192.168.1.1 设置路由器。 ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:5:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"2.3 翻车自救 翻车嘛，在所难免…… 翻车不可怕，只要nmrp没坏，还是有救的，具体可参照 2.2 中 nmrpflash 刷机步骤进行重刷。 也可以通过 nmrpflash 重新刷回官方固件(辣鸡官方固件，应该没人会刷回去……)。 3 OpenWrt 后续配置 ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:6:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"3.1 修改默认Lan IP openwrt 默认lan IP 是 192.168.1.1，与光猫冲突了，改成别的地址 ssh到路由器 $ uci set network.lan.ipaddr=192.168.111.1 $ uci commit \u0026\u0026 service network restart ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:7:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"3.2 SSH 密钥登陆 参考官方文档 Dropbear key-based authentication root用户需要把公钥放到 /etc/dropbear/authorized_keys ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:8:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"3.3 privoxy 配置 # /etc/config/privoxy config privoxy 'privoxy' option confdir '/etc/privoxy' option logdir '/var/log' option logfile 'privoxy.log' list listen_address '192.168.111.1:8118' option forward_socks5 '/ 192.168.111.1:65530 .' ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:9:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"3.4 出国留学 使用自用的magic协议，这里不可描述，略过。 此外还要配置pac文件。 使用工具生产pac文件，代理地址为PROXY 192.168.111.1:8118，并把该文件放到路由器的/www/xxx.pac 在手机上把pac地址配置为 http://192.168.111.1/xxx.pac ","date":"2021-05-03","objectID":"/2021-05-03-netgear-r6850-openwrt/:10:0","tags":["openwrt"],"title":"Netgear R6850刷openwrt","uri":"/2021-05-03-netgear-r6850-openwrt/"},{"categories":null,"content":"官方blog传送门：https://blog.golang.org/defer-panic-and-recover ","date":"2019-05-16","objectID":"/2019-05-16-go-defer-panic-recover/:0:0","tags":["golang","备忘"],"title":"go笔记 defer,panic,recover","uri":"/2019-05-16-go-defer-panic-recover/"},{"categories":null,"content":"defer A defer statement pushes a function call onto a list. The list of saved calls is executed after the surrounding function returns. Defer is commonly used to simplify functions that perform various clean-up actions. defer类似cpp在对象在离开作用于后析构，defer可以多次，这样形成一个defer栈，后defer的语句在函数返回时将先被调用。 func CopyFile(dstName, srcName string) (written int64, err error) { src, err := os.Open(srcName) if err != nil { return } defer src.Close() dst, err := os.Create(dstName) if err != nil { return } defer dst.Close() return io.Copy(dst, src) } ","date":"2019-05-16","objectID":"/2019-05-16-go-defer-panic-recover/:1:0","tags":["golang","备忘"],"title":"go笔记 defer,panic,recover","uri":"/2019-05-16-go-defer-panic-recover/"},{"categories":null,"content":"panic Panic is a built-in function that stops the ordinary flow of control and begins panicking. When the function F calls panic, execution of F stops, any deferred functions in F are executed normally, and then F returns to its caller. To the caller, F then behaves like a call to panic. The process continues up the stack until all functions in the current goroutine have returned, at which point the program crashes. Panics can be initiated by invoking panic directly. They can also be caused by runtime errors, such as out-of-bounds array accesses. 执行panic后，函数不在往下走，会调用defer package main import ( \"fmt\" ) func main() { defer_call() } func defer_call() { defer func() { fmt.Println(\"111\") }() defer func() { fmt.Println(\"222\") }() defer func() { fmt.Println(\"333\") }() panic(\"panic\") } /* 输出: 333 222 111 panic: panic goroutine 1 [running]: main.defer_call() C:/Users/lch/go/src/github.com/lchannng/gopl/defer/main.go:21 +0x98 main.main() C:/Users/lch/go/src/github.com/lchannng/gopl/defer/main.go:14 +0x27 */ ","date":"2019-05-16","objectID":"/2019-05-16-go-defer-panic-recover/:2:0","tags":["golang","备忘"],"title":"go笔记 defer,panic,recover","uri":"/2019-05-16-go-defer-panic-recover/"},{"categories":null,"content":"recover Recover is a built-in function that regains control of a panicking goroutine. Recover is only useful inside deferred functions. During normal execution, a call to recover will return nil and have no other effect. If the current goroutine is panicking, a call to recover will capture the value given to panic and resume normal execution. 按上面所说，panic的函数并不会立刻返回，而是先defer，再返回。这时候可在defer中将panic捕获到，并阻止panic传递，save the world。 一个类似try catch的例子 func Try(f func(), handler func(interface{}) { defer func() { if err := recover(); err != nil { handler(err) } } f() }) func main() { Try(func() { panic(\"oh!panic.\") }, func(e interface{}) { fmt.Println(e) }) } ","date":"2019-05-16","objectID":"/2019-05-16-go-defer-panic-recover/:3:0","tags":["golang","备忘"],"title":"go笔记 defer,panic,recover","uri":"/2019-05-16-go-defer-panic-recover/"},{"categories":null,"content":"文档传送门(https://dev.mysql.com/doc/refman/8.0/en/windows-installation.html) 从noinstall ZIP Archive安装 初始化data目录 mysqld --initialize --console 登录, 输入随机生成的密码 mysql -u root -p 修改密码 ALTER USER 'root'@'localhost' IDENTIFIED BY 'your-password'; ","date":"2019-05-14","objectID":"/2019-05-14-installing-mysql-on-windows/:0:0","tags":["备忘","mysql"],"title":"Windows下安装mysql","uri":"/2019-05-14-installing-mysql-on-windows/"}]